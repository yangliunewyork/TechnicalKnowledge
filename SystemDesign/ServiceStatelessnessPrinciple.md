## Introduction
Service statelessness is a design principle that is applied within the service-orientation design paradigm, in order to design scalable services by separating them from their state data whenever possible. This results in reduction of the resources consumed by a service as the actual state data management is delegated to an external component or to an architectural extension. By reducing resource consumption, the service can handle more requests in a reliable manner.

## Purpose
The interaction of any two software programs involves keeping track of the interaction-specific data as each subsequent interaction may depend upon the outcome of the previous interaction. This becomes more important in distributed architectures where the client and the server do not exist physically on the same machine. In two-tier architectures, the responsibility of tracking this interaction-specific data rested upon the rich clients, which was not an issue as each client used to reside on an individual computer. However, within n-tier architectures, the state management responsibility shifted from the client to the application or the web server. This introduced the need for some middleware state management extensions so that the server could handle multiple concurrent client requests by deferring the actual activity-specific state data to such extensions e.g. storing session data in a database in ASP .NET applications. This helps freeing up the memory resources in favor of increasing server responsiveness and the ability to entertain more client requests.

In a service composition, a service may need to store activity-specific data in memory while it is waiting for another service to complete its processing. Consequently, in case of service-orientation, an efficient management of service activity related data becomes more important as service-orientation puts a lot of emphasizes on service reuse. The service not only needs to deal with managing state data, which is created as a result of interacting with a consumer program, in the context of a particular business process but also in relation to the interactions with other types of consumer programs that are part of multiple business processes. As reusability goes up, so does the overhead of managing state data. The Service Statelessness principle provides guidelines in favor of making the service stateless by shifting away the state management overhead from the services to some other external architectural component. This further helps in the overall scalability of the service-oriented solution.

## Considerations
It may not always be possible to provide a dedicated state deferral option for each service as this clearly requires additional investment. On the other hand, using a shared state deferral option may create a dependency for the service, which may stand in way of service evolution.

The storage and retrieval of state information may inadvertently affect the response time of the service as both of these tasks may prove computationally intensive as first the data needs to be converted into the native format of the storage extension and vice versa when it comes to retrieving the same information.

Designing stateless services requires extra efforts and time as the service needs to contain logic that interfaces with the state deferral extensions. This in turn would require additional code and testing.
