## What is File Descriptor?

![alt](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f8/File_table_and_inode_table.svg/600px-File_table_and_inode_table.svg.png)

In Unix and related computer operating systems, a file descriptor (FD, less frequently fildes) is an abstract indicator (handle) used to access a file or other input/output resource, such as a pipe or network socket. File descriptors form part of the POSIX application programming interface. A file descriptor is a non-negative integer, generally represented in the C programming language as the type int (negative values being reserved to indicate "no value" or an error condition).

Each Unix process (except perhaps a daemon) should expect to have three standard POSIX file descriptors, corresponding to the three standard streams:

| Integer value |	Name |	<unistd.h> symbolic constant |	<stdio.h> file stream |
| ------------- |:-------------:| -----:|-----:|
| 0	| Standard input |	STDIN_FILENO	| stdin |
| 1	| Standard output	| STDOUT_FILENO	| stdout |
| 2	| Standard error	| STDERR_FILENO	| stderr |

## Overview
In the traditional implementation of Unix, file descriptors index into a per-process file descriptor table maintained by the kernel, that in turn indexes into a system-wide table of files opened by all processes, called the file table. This table records the mode with which the file (or other resource) has been opened: for reading, writing, appending, reading and writing, and possibly other modes. It also indexes into a third table called the inode table that describes the actual underlying files. To perform input or output, the process passes the file descriptor to the kernel through a system call, and the kernel will access the file on behalf of the process. The process does not have direct access to the file or inode tables.

On Linux, the set of file descriptors open in a process can be accessed under the path /proc/PID/fd/, where PID is the process identifier.

In Unix-like systems, file descriptors can refer to any Unix file type named in a file system. As well as regular files, this includes directories, block and character devices (also called "special files"), Unix domain sockets, and named pipes. File descriptors can also refer to other objects that do not normally exist in the file system, such as anonymous pipes and network sockets.

The FILE data structure in the C standard I/O library usually includes a low level file descriptor for the object in question on Unix-like systems. The overall data structure provides additional abstraction and is instead known as a file handle.

## Detail
The Standard UNIX File Descriptors - Standard Input (stdin), Standard Output (stdout), and Standard Error (stderr)

If you are familiar with UNIX I/O redirection, syntax similar to the following should not be new to you:
```
command > file 2>&1
```
Briefly, when command runs it sends "normal" output to file, and any error messages generated by command are also written to file. "2>&1" handles the latter.

Have you ever wondered where the numbers 2 and 1 come from? This may be common knowledge to our more experienced readers, but may need some explaining to those who are relatively new to the UNIX operating system environment. The 2 and 1 are file descriptors. Okay, so what's a file descriptor?

When a UNIX program wants to use a file, it must first open that file. When it does so, UNIX will associate a number with the file. This number, which is used by the program when reading from and writing to the file, is the file descriptor.

A typical UNIX program will open three files when it starts. These files are: 

- standard input (also known as stdin)
- standard output (also known as stdout)
- standard error (also known as stderr)

Standard input has a file descriptor of 0, standard output uses 1, and the number 2 is used by standard error. Are you starting to see where this is headed?

Looking at our command again,
```
command > file 2>&1
```
you should now recognize that 2>&1 instructs the shell to send messages headed to stderr (2) to the same place messages to stdout (1) are sent. In our example, that place is file.

In case you were wondering...

**> is equivalent to 1>**

and

**< is short for <0**
