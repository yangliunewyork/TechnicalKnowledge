* Also note that the function doesn't define a return datatype. Python functions do not specify the datatype of their return value; they don't even specify whether or not they return a value. In fact, every Python function returns a value; if the function ever executes a return statement, it will return that value, otherwise it will return None, the Python null value.
* In Python, variables are never explicitly typed. Python figures out what type a variable is and keeps track of it internally.
* Python is both dynamically typed (because it doesn't use explicit datatype declarations) and strongly typed (because once a variable has a datatype, it actually matters).
* Everything between the triple quotes is the function's doc string, which documents what the function does. A doc string, if it exists, must be the first thing defined in a function (that is, the first thing after the colon). You don't technically need to give your function a doc string, but you always should. I know you've heard this in every programming class you've ever taken, but Python gives you an added incentive: the doc string is available at runtime as an attribute of the function.
* A function, like everything else in Python, is an object.
* Before you go any further, I want to briefly mention the library search path. Python looks in several places when you try to import a module. Specifically, it looks in all the directories defined in sys.path. This is just a list, and you can easily view it or modify it with standard list methods.
* sys.path is a list of directory names that constitute the current search path. (Yours will look different, depending on your operating system, what version of Python you're running, and where it was originally installed.) Python will look through these directories (in this order) for a .py file matching the module name you're trying to import.
* Everything in Python is an object, and almost everything has attributes and methods. All functions have a built-in attribute __doc__, which returns the doc string defined in the function's source code. The sys module is an object which has (among other things) an attribute called path. And so forth.
* Python functions have no explicit begin or end, and no curly braces to mark where the function code starts and stops. The only delimiter is a colon (:) and the indentation of the code itself.
* Modules are objects, and all modules have a built-in attribute ```__name__```. A module's ```__name__``` depends on how you're using the module. If you import the module, then ```__name__``` is the module's filename, without a directory path or file extension. But you can also run the module directly as a standalone program, in which case ```__name__``` will be a special default value, ```__main__```.Knowing this, you can design a test suite for your module within the module itself by putting it in this if statement. When you run the module directly, ```__name__``` is ```__main__```, so the test suite executes. When you import the module, ```__name__``` is something else, so the test suite is ignored. This makes it easier to develop and debug new modules before integrating them into a larger program.
* A dictionary in Python is like an instance of the Hashtable class in Java.
* A list in Python is much more than an array in Java (although it can be used as one if that's really all you want out of life). A better analogy would be to the ArrayList class, which can hold arbitrary objects and can expand dynamically as new items are added.
* A tuple is an immutable list. A tuple can not be changed in any way once it is created.Tuples are faster than lists. If you're defining a constant set of values and all you're ever going to do with it is iterate through it, use a tuple instead of a list.It makes your code safer if you “write-protect” data that does not need to be changed. Using a tuple instead of a list is like having an implied assert statement that shows this data is constant, and that special thought (and a specific function) is required to override that.
* Python has local and global variables like most other languages, but it has no explicit variable declarations. Variables spring into existence by being assigned a value, and they are automatically destroyed when they go out of scope.
